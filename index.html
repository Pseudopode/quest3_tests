<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Quest 3 MR Primitives + Physics (RATK + three + Rapier)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- (Optional) Import maps polyfill for older Chromium builds -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>

  <!-- Import map: three, addons, RATK, and Rapier -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/",
      "ratk": "https://esm.sh/ratk@0.3.0",
      "@dimforge/rapier3d-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.19.2/rapier.mjs"
    }
  }
  </script>

  <style>
    html, body { margin: 0; padding: 0; background: #000; height: 100%; overflow: hidden; }
    #enter-ar { 
      position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%);
      font: 600 16px system-ui, sans-serif; color: #000; background: #00e0b8;
      border: none; border-radius: 999px; padding: 12px 20px; cursor: pointer;
      box-shadow: 0 6px 24px rgba(0,0,0,0.25);
    }
    #enter-ar:disabled { background: #555; color: #ddd; cursor: default; }
    /* On Quest, the button is converted by RATK.ARButton; keeping style here for desktop fallback */
  </style>
</head>
<body>
  <button id="enter-ar">Enter Mixed Reality</button>
  <script type="module">
    import * as THREE from 'three';
    import { ARButton, RealityAccelerator } from 'ratk';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
    import RAPIER from '@dimforge/rapier3d-compat';

    // ---------- Globals ----------
    let renderer, scene, camera, ratk, hitTarget, reticle;
    let rapierWorld, rapierReady = false;
    const dynamicBodies = []; // { mesh, body }
    const planeColliders = new Map(); // plane.uuid -> { body, collider }
    const INTERACTABLES = []; // UI button meshes

    // User-settable defaults (affect newly spawned objects)
    let CURRENT_SHAPE = 'box';      // 'box' | 'sphere' | 'cylinder'
    let CURRENT_COLOR = new THREE.Color('#ff6b6b');
    let CURRENT_FRICTION = 0.6;     // 0..1
    let CURRENT_RESTITUTION = 0.1;  // 0..1

    // ---------- Basic three.js + WebXR setup ----------
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lights (virtual objects will be lit over passthrough)
    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.65);
    dir.position.set(0.5, 1.0, 0.5);
    scene.add(dir);

    // ---------- Convert the button to an AR/WebXR starter via RATK ----------
    const arBtn = document.getElementById('enter-ar');
    ARButton.convertToARButton(arBtn, renderer, {
      sessionInit: {
        requiredFeatures: ['hit-test', 'plane-detection', 'mesh-detection', 'anchors'],
        optionalFeatures: [] // add 'hand-tracking' if desired
      }
    });
    // RATK exposes this helper; it wraps WebXR button creation and feature requests. :contentReference[oaicite:4]{index=4}

    // ---------- RATK root ----------
    ratk = new RealityAccelerator(renderer.xr);
    scene.add(ratk.root); // keep RATK's root in the scene so planes/meshes/anchors appear. :contentReference[oaicite:5]{index=5}

    // ---------- Hit-test reticle ----------
    reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.03, 0.035, 32),
      new THREE.MeshBasicMaterial({ color: 0x00e0b8, side: THREE.DoubleSide })
    );
    reticle.rotation.x = -Math.PI / 2;
    reticle.visible = false;
    scene.add(reticle);

    // ---------- Controllers (for ray-based UI) ----------
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();
    const controllers = [];
    const controllerModels = [];
    const controllerFactory = new XRControllerModelFactory();

    for (let i = 0; i < 2; i++) {
      const c = renderer.xr.getController(i);
      c.addEventListener('selectstart', onSelectStart);
      scene.add(c);
      controllers.push(c);

      const grip = renderer.xr.getControllerGrip(i);
      grip.add(controllerFactory.createControllerModel(grip));
      scene.add(grip);
      controllerModels.push(grip);

      // simple laser pointer
      const lineGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
      const line = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({ transparent: true, opacity: 0.6 }));
      line.name = 'laser';
      line.scale.z = 0.2;
      c.add(line);
    }

    function setRayFromController(controller) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    }

    // ---------- Rapier physics ----------
    await RAPIER.init(); // load WASM
    rapierWorld = new RAPIER.World({ x: 0, y: -9.81, z: 0 }); // gravity
    rapierReady = true;

    // ---------- UI: an anchored 3D toolbar ----------
    // We’ll create a world-locked anchor ~0.6m in front of the user once the session actually starts.
    let uiPanel = null;

    renderer.xr.addEventListener('sessionstart', async () => {
      // 1) Create a viewer-space hit-test source (visualized with reticle).
      hitTarget = await ratk.createHitTestTargetFromViewerSpace(new THREE.Vector3(), new THREE.Quaternion());
      // 2) Place a world-locked UI anchor in front of the viewer.
      // Grab the viewer pose via camera, project forward.
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const uiPos = camera.position.clone().add(forward.multiplyScalar(0.6));
      const uiQuat = camera.quaternion.clone();
      const uiAnchor = await ratk.createAnchor(uiPos, uiQuat, false); // not persistent
      uiPanel = buildUI();
      uiAnchor.add(uiPanel);
    });

    // ---------- RATK planes => Rapier static colliders ----------
    ratk.onPlaneAdded = (plane) => {
      // Only horizontal surfaces are used as "tables/floors" for placement/physics support.
      if (plane.orientation !== 'Horizontal') return;

      // Build a thin cuboid collider the size of the plane’s bounding rectangle, aligned to plane transform.
      const halfW = Math.max(0.05, (plane.boundingRectangleWidth  ?? 0.5) / 2);
      const halfH = Math.max(0.05, (plane.boundingRectangleHeight ?? 0.5) / 2);
      const thickness = 0.01; // 2 cm total thickness

      // Get plane world transform (Plane extends Object3D in RATK) :contentReference[oaicite:6]{index=6}
      plane.updateWorldMatrix(true, false);
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      plane.getWorldPosition(pos);
      plane.getWorldQuaternion(quat);

      const rbDesc = RAPIER.RigidBodyDesc.fixed()
        .setTranslation(pos.x, pos.y, pos.z)
        .setRotation({ w: quat.w, x: quat.x, y: quat.y, z: quat.z }); // quaternion form
      const rb = rapierWorld.createRigidBody(rbDesc);

      const colDesc = RAPIER.ColliderDesc.cuboid(halfW, thickness, halfH)
        .setFriction(CURRENT_FRICTION)
        .setRestitution(CURRENT_RESTITUTION);
      const col = rapierWorld.createCollider(colDesc, rb);

      planeColliders.set(plane.uuid, { rb, col });
    };

    ratk.onPlaneDeleted = (plane) => {
      const entry = planeColliders.get(plane.uuid);
      if (!entry) return;
      rapierWorld.removeRigidBody(entry.rb);
      planeColliders.delete(plane.uuid);
    };

    // ---------- UI building ----------
    function buildUI() {
      // A 40cm wide panel with simple buttons
      const panelW = 0.42, panelH = 0.20;
      const g = new THREE.Group();
      g.position.set(0, -0.05, -0.08); // small local offset in anchor space

      const bg = new THREE.Mesh(
        new THREE.PlaneGeometry(panelW, panelH, 1, 1),
        new THREE.MeshBasicMaterial({ color: 0x111111, transparent: true, opacity: 0.7 })
      );
      bg.userData.ignore = true;
      g.add(bg);

      const title = makeTextSprite('MR Toolkit', 0.035, 0xffffff);
      title.position.set(-panelW*0.46, panelH*0.4, 0.001);
      g.add(title);

      // Shape buttons
      const btnY = 0.02;
      const bx   = makeButton('Box',      () => CURRENT_SHAPE = 'box');
      const sp   = makeButton('Sphere',   () => CURRENT_SHAPE = 'sphere');
      const cy   = makeButton('Cylinder', () => CURRENT_SHAPE = 'cylinder');
      layoutRow([bx, sp, cy], g, -panelW/2 + 0.07, btnY, 0.12);

      // Color swatches
      const colors = [ '#ff6b6b', '#ffd166', '#06d6a0', '#118ab2', '#c77dff', '#ffffff' ];
      const swatches = colors.map(hex => makeSwatch(hex, () => { CURRENT_COLOR.set(hex); }));
      layoutRow(swatches, g, -panelW/2 + 0.07, -0.03, 0.06);

      // Friction and Restitution steppers
      const fric = makeStepper('Friction', () => CURRENT_FRICTION = clamp01(CURRENT_FRICTION - 0.1), () => CURRENT_FRICTION = clamp01(CURRENT_FRICTION + 0.1), () => CURRENT_FRICTION);
      const rest = makeStepper('Bounce',   () => CURRENT_RESTITUTION = clamp01(CURRENT_RESTITUTION - 0.1), () => CURRENT_RESTITUTION = clamp01(CURRENT_RESTITUTION + 0.1), () => CURRENT_RESTITUTION);
      fric.position.set(panelW*0.05, btnY, 0.001);
      rest.position.set(panelW*0.05, -0.03, 0.001);
      g.add(fric, rest);

      return g;
    }

    function layoutRow(items, parent, startX, y, dx) {
      let x = startX;
      for (const m of items) {
        m.position.set(x, y, 0.002);
        parent.add(m);
        INTERACTABLES.push(m);
        x += dx;
      }
    }

    function makeButton(label, onClick) {
      const w = 0.10, h = 0.035;
      const base = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ color: 0x222222 }));
      const txt = makeTextSprite(label, 0.025, 0xffffff);
      txt.position.set(-w*0.42, 0, 0.001);
      base.add(txt);
      base.userData.onClick = onClick;
      return base;
    }

    function makeSwatch(hex, onClick) {
      const w = 0.05, h = 0.03;
      const base = new THREE.Mesh(new THREE.PlaneGeometry(w, h), new THREE.MeshBasicMaterial({ color: new THREE.Color(hex) }));
      base.userData.onClick = onClick;
      return base;
    }

    function makeStepper(title, onMinus, onPlus, getValue) {
      const g = new THREE.Group();
      const label = makeTextSprite(title, 0.024, 0xffffff);
      label.position.set(-0.07, 0, 0.001);
      g.add(label);

      const minus = new THREE.Mesh(new THREE.PlaneGeometry(0.03, 0.03), new THREE.MeshBasicMaterial({ color: 0x333333 }));
      minus.add(makeTextSprite('–', 0.03, 0xffffff)).position.set(-0.009, -0.001, 0.001);
      minus.userData.onClick = () => { onMinus(); valueText.text = num(getValue()); valueText.sync?.(); };
      minus.position.set(0.00, 0, 0.001);

      const plus  = new THREE.Mesh(new THREE.PlaneGeometry(0.03, 0.03), new THREE.MeshBasicMaterial({ color: 0x333333 }));
      plus.add(makeTextSprite('+', 0.03, 0xffffff)).position.set(-0.009, -0.001, 0.001);
      plus.userData.onClick = () => { onPlus(); valueText.text = num(getValue()); valueText.sync?.(); };
      plus.position.set(0.10, 0, 0.001);

      const valueText = makeTextSprite(num(getValue()), 0.026, 0x00e0b8);
      valueText.position.set(0.055, 0, 0.001);

      g.add(minus, valueText, plus);
      INTERACTABLES.push(minus, plus);
      return g;
    }

    function num(v) { return String(Math.round(v * 100) / 100); }
    function clamp01(v) { return Math.max(0, Math.min(1, v)); }

    // Very small canvas-based text sprites (keeps dependencies minimal)
    function makeTextSprite(text, size = 0.03, color = 0xffffff) {
      const cvs = document.createElement('canvas');
      const ctx = cvs.getContext('2d');
      ctx.font = '64px system-ui, sans-serif';
      const m = ctx.measureText(text);
      cvs.width = Math.max(2, Math.ceil(m.width) + 8);
      cvs.height = 80;
      ctx.font = '64px system-ui, sans-serif';
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, cvs.width, cvs.height);
      ctx.fillStyle = typeof color === 'number' ? '#' + new THREE.Color(color).getHexString() : color;
      ctx.fillText(text, 4, 60);
      const tex = new THREE.CanvasTexture(cvs);
      tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.needsUpdate = true;
      const aspect = cvs.width / cvs.height;
      const sprite = new THREE.Mesh(new THREE.PlaneGeometry(size * aspect, size), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
      // Add a tiny API to update text in place
      sprite.text = text;
      sprite.sync = () => {
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, cvs.width, cvs.height);
        ctx.fillStyle = typeof color === 'number' ? '#' + new THREE.Color(color).getHexString() : color;
        ctx.fillText(sprite.text, 4, 60);
        tex.needsUpdate = true;
      };
      return sprite;
    }

    // ---------- Controller interactions ----------
    function onSelectStart(event) {
      const controller = event.target;
      // 1) Attempt UI click
      setRayFromController(controller);
      const hits = raycaster.intersectObjects(INTERACTABLES, true);
      if (hits.length) {
        let obj = hits[0].object;
        // walk up to the plane mesh that holds onClick
        while (obj && !obj.userData?.onClick) obj = obj.parent;
        if (obj && obj.userData?.onClick) { obj.userData.onClick(); return; }
      }

      // 2) Otherwise place primitive at reticle hit
      if (reticle.visible) {
        placePrimitive(reticle.position, reticle.quaternion);
      }
    }

    function placePrimitive(pos, quat) {
      const material = new THREE.MeshStandardMaterial({ color: CURRENT_COLOR, roughness: 0.85, metalness: 0.1 });
      let mesh, body, collider;
      if (CURRENT_SHAPE === 'box') {
        const s = 0.15;
        mesh = new THREE.Mesh(new THREE.BoxGeometry(s, s, s), material);
        body = rapierWorld.createRigidBody(
          RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(pos.x, pos.y + s*0.5 + 0.01, pos.z)
            .setRotation({ w: quat.w, x: quat.x, y: quat.y, z: quat.z })
        );
        collider = rapierWorld.createCollider(
          RAPIER.ColliderDesc.cuboid(s/2, s/2, s/2).setFriction(CURRENT_FRICTION).setRestitution(CURRENT_RESTITUTION),
          body
        );
      } else if (CURRENT_SHAPE === 'sphere') {
        const r = 0.09;
        mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 24, 16), material);
        body = rapierWorld.createRigidBody(
          RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(pos.x, pos.y + r + 0.01, pos.z)
            .setRotation({ w: quat.w, x: quat.x, y: quat.y, z: quat.z })
        );
        collider = rapierWorld.createCollider(
          RAPIER.ColliderDesc.ball(r).setFriction(CURRENT_FRICTION).setRestitution(CURRENT_RESTITUTION),
          body
        );
      } else {
        // cylinder
        const r = 0.07, h = 0.14;
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(r, r, h, 20), material);
        body = rapierWorld.createRigidBody(
          RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(pos.x, pos.y + h*0.5 + 0.01, pos.z)
            .setRotation({ w: quat.w, x: quat.x, y: quat.y, z: quat.z })
        );
        collider = rapierWorld.createCollider(
          RAPIER.ColliderDesc.cylinder(h/2, r).setFriction(CURRENT_FRICTION).setRestitution(CURRENT_RESTITUTION),
          body
        );
      }
      scene.add(mesh);
      dynamicBodies.push({ mesh, body });
    }

    // ---------- Animation loop ----------
    const clock = new THREE.Clock();
    renderer.setAnimationLoop(() => {
      const dt = Math.min(0.05, clock.getDelta());

      // Update RATK (polls planes/meshes/anchors/hit-tests)
      ratk.update(); // call every frame per docs :contentReference[oaicite:7]{index=7}

      // If we have a hitTarget, move the reticle to its pose when valid
      if (hitTarget && hitTarget.hitTestResultValid) {
        reticle.visible = true;
        reticle.position.copy(hitTarget.position);
        reticle.quaternion.copy(hitTarget.quaternion);
      } else {
        reticle.visible = false;
      }

      // Step physics and sync meshes
      if (rapierReady) {
        rapierWorld.timestep = dt;
        rapierWorld.step();
        for (const { mesh, body } of dynamicBodies) {
          const t = body.translation();
          const r = body.rotation();
          mesh.position.set(t.x, t.y, t.z);
          mesh.quaternion.set(r.x, r.y, r.z, r.w);
        }
      }

      renderer.render(scene, camera);
    });

    // ---------- Resizing ----------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
