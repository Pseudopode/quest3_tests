<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta http-equiv="Cache-Control" content="no-cache">
<title>Quest 3 MR Cloth + In‑Scene UI + Gizmo (single file)</title>
<style>
  :root { --ui-bg: rgba(15,15,20,0.7); --ui-fg: #fff; --ui-ac: #66d; }
  html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif; color:var(--ui-fg); }
  #xr-canvas { width:100vw; height:100vh; display:block; background:#000; }
  .hud {
    position: fixed; left: 0; right: 0; top: 0; display:flex; justify-content:center; padding: 8px;
    pointer-events:none; z-index:10;
  }
  .panel {
    pointer-events:auto;
    background: var(--ui-bg);
    border: 1px solid rgba(255,255,255,0.15);
    backdrop-filter: blur(6px);
    border-radius: 10px; padding: 10px 12px; display:flex; gap:8px; align-items:center;
    box-shadow: 0 4px 18px rgba(0,0,0,0.35);
  }
  button {
    appearance:none; border:1px solid rgba(255,255,255,0.22); border-radius:8px;
    background:#1a1f29; color:var(--ui-fg); padding:8px 12px; font-weight:600; cursor:pointer;
  }
  button.primary { background: var(--ui-ac); border-color: #445; }
  button:disabled { opacity: .5; cursor: not-allowed; }
  #msg { font-size: 14px; opacity: .9; }
  .footer {
    position: fixed; left: 0; right: 0; bottom: 0; display:flex; justify-content:center; padding: 8px; z-index:10; pointer-events:none;
  }
  .footer .panel { pointer-events:auto; }
  .dot { width:8px; height:8px; border-radius:50%; background:#8fd; display:inline-block; margin-right:6px; }
  a { color:#9cf; }
</style>
</head>
<body>
<canvas id="xr-canvas" aria-label="Mixed Reality cloth canvas"></canvas>

<div class="hud">
  <div class="panel">
    <span class="dot" id="statusDot" title="Session status"></span>
    <div id="msg">Ready.</div>
    <button id="enter" class="primary">Enter Mixed Reality</button>
    <button id="reset">Reset</button>
  </div>
</div>

<div class="footer">
  <div class="panel" style="font-size:13px; line-height:1.2;">
    <div><b>In‑scene UI</b>: Press colored squares: <span style="color:#f66">Reset</span>, <span style="color:#6f6">Re‑arm Reticle</span>, <span style="color:#ffdb4d">Toggle Gizmo</span>. Gizmo: grab <b>X/Z/Y</b> arrows to move, <b>ring</b> to rotate.</div>
  </div>
</div>

<script type="module">
'use strict';

/* -------------------------- Minimal math utils --------------------------- */
const V = {
  add:(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],
  sub:(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],
  mul:(a,s)=>[a[0]*s,a[1]*s,a[2]*s],
  dot:(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],
  cross:(a,b)=>[a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]],
  len:(a)=>Math.hypot(a[0],a[1],a[2]),
  norm:(a)=>{ const L=V.len(a)||1; return [a[0]/L,a[1]/L,a[2]/L]; }
};
function mat4Identity(){ return [1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]; }
function mat4Multiply(a,b){ // a*b (column-major)
  const o=new Float32Array(16);
  for(let c=0;c<4;c++) for(let r=0;r<4;r++){
    o[c*4+r]=a[0*4+r]*b[c*4+0]+a[1*4+r]*b[c*4+1]+a[2*4+r]*b[c*4+2]+a[3*4+r]*b[c*4+3];
  }
  return o;
}
function mat4FromPose(pose){ return pose ? new Float32Array(pose.matrix) : new Float32Array(mat4Identity()); }
function mat4InverseRigid(m){ // inverse of rigid transform (R,t)
  const r00=m[0], r01=m[1], r02=m[2];
  const r10=m[4], r11=m[5], r12=m[6];
  const r20=m[8], r21=m[9], r22=m[10];
  const tx = m[12], ty = m[13], tz = m[14];
  const o = new Float32Array(16);
  o[0]=r00; o[1]=r10; o[2]=r20; o[3]=0;
  o[4]=r01; o[5]=r11; o[6]=r21; o[7]=0;
  o[8]=r02; o[9]=r12; o[10]=r22; o[11]=0;
  o[12]=-(o[0]*tx + o[4]*ty + o[8]*tz);
  o[13]=-(o[1]*tx + o[5]*ty + o[9]*tz);
  o[14]=-(o[2]*tx + o[6]*ty + o[10]*tz);
  o[15]=1;
  return o;
}
function transformPoint(m,p){
  return [
    m[0]*p[0]+m[4]*p[1]+m[8]*p[2]+m[12],
    m[1]*p[0]+m[5]*p[1]+m[9]*p[2]+m[13],
    m[2]*p[0]+m[6]*p[1]+m[10]*p[2]+m[14],
  ];
}
function transformVector(m,v){ // ignore translation
  return [
    m[0]*v[0]+m[4]*v[1]+m[8]*v[2],
    m[1]*v[0]+m[5]*v[1]+m[9]*v[2],
    m[2]*v[0]+m[6]*v[1]+m[10]*v[2],
  ];
}
function composeFromBasis(r,u,f,t){ // columns = r,u,f,t (column-major)
  return new Float32Array([
    r[0], r[1], r[2], 0,
    u[0], u[1], u[2], 0,
    f[0], f[1], f[2], 0,
    t[0], t[1], t[2], 1
  ]);
}
function quatToBasisY(q){ // rotate (0,1,0) by quaternion
  const [x,y,z,w]=q;
  const vx = 2*(x*y + w*z);
  const vy = 1 - 2*(x*x + z*z);
  const vz = 2*(y*z - w*x);
  return [vx,vy,vz];
}
function quatFromMat(m){ // approximate quaternion from rotation part
  const m00=m[0], m11=m[5], m22=m[10];
  const tr=m00+m11+m22;
  let x,y,z,w;
  if(tr>0){ const S=Math.sqrt(tr+1.0)*2; w=0.25*S; x=(m[6]-m[9])/S; y=(m[8]-m[2])/S; z=(m[1]-m[4])/S; }
  else if((m00>m11)&(m00>m22)){ const S=Math.sqrt(1.0+m00-m11-m22)*2; w=(m[6]-m[9])/S; x=0.25*S; y=(m[4]+m[1])/S; z=(m[8]+m[2])/S; }
  else if(m11>m22){ const S=Math.sqrt(1.0+m11-m00-m22)*2; w=(m[8]-m[2])/S; x=(m[4]+m[1])/S; y=0.25*S; z=(m[9]+m[6])/S; }
  else { const S=Math.sqrt(1.0+m22-m00-m11)*2; w=(m[1]-m[4])/S; x=(m[8]+m[2])/S; y=(m[9]+m[6])/S; z=0.25*S; }
  return [x,y,z,w];
}
function rodrigues(v, axis, angle){ // rotate vector v around axis
  const a = V.norm(axis), s=Math.sin(angle), c=Math.cos(angle);
  const dot = V.dot(a,v);
  const cross = V.cross(a,v);
  return V.add(V.add(V.mul(v,c), V.mul(cross,s)), V.mul(a, (1-c)*dot));
}

/* ----------------------------- GL boilerplate ---------------------------- */
const canvas = document.getElementById('xr-canvas');
let gl;
let session, refSpace, viewerSpace, baseLayer, hitTestSource;

function createGL(){
  gl = canvas.getContext('webgl', { alpha:true, antialias:true, xrCompatible:true });
  if(!gl) throw new Error('WebGL not supported');
}
function compile(gl, src, type){
  const sh = gl.createShader(type); gl.shaderSource(sh, src); gl.compileShader(sh);
  if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh));
  return sh;
}
function link(gl, vs, fs){
  const p = gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
  return p;
}

/* ------------------------------- Shaders -------------------------------- */
const VS = `
attribute vec3 aPos;
attribute vec3 aNor;
attribute vec2 aUV;
uniform mat4 uProj, uView, uModel;
varying vec3 vN; varying vec3 vW; varying vec2 vUV;
void main(){
  vec4 wPos = uModel * vec4(aPos,1.0);
  vW = wPos.xyz;
  vN = mat3(uModel) * aNor;
  vUV = aUV;
  gl_Position = uProj * uView * wPos;
}`;
const FS = `
precision mediump float;
varying vec3 vN; varying vec3 vW; varying vec2 vUV;
uniform vec3 uEye; uniform vec3 uLightDir; uniform vec3 uBaseColor; uniform float uMetal; uniform float uRough;
void main(){
  vec3 N = normalize(vN);
  vec3 L = normalize(-uLightDir);
  vec3 Vv = normalize(uEye - vW);
  vec3 H = normalize(L+Vv);
  float ndl = max(dot(N,L), 0.0);
  float ndh = max(dot(N,H), 0.0);
  float spec = pow(ndh, mix(24.0, 4.0, clamp(uRough,0.0,1.0)));
  vec3 base = uBaseColor;
  vec3 color = base * (0.15 + 0.85*ndl) + vec3(0.6) * spec * (1.0 - uRough);
  gl_FragColor = vec4(color, 1.0);
}`;
// color-only program (reticle, UI, gizmo)
const VS2 = `attribute vec3 aPos; uniform mat4 uProj, uView, uModel; void main(){ gl_Position = uProj * uView * uModel * vec4(aPos,1.0); }`;
const FS2 = `precision mediump float; uniform vec4 uColor; void main(){ gl_FragColor = uColor; }`;

/* ------------------------------ Geometry -------------------------------- */
let progMain, progLine;
let bufPos, bufNor, bufUV, bufIdx; // cloth
let bufReticle, bufTemp; // line loop + dynamic triangles/lines
let loc = {}, loc2 = {};

function initPrograms(){
  const vs = compile(gl, VS, gl.VERTEX_SHADER);
  const fs = compile(gl, FS, gl.FRAGMENT_SHADER);
  progMain = link(gl, vs, fs);
  loc = {
    aPos: gl.getAttribLocation(progMain, 'aPos'),
    aNor: gl.getAttribLocation(progMain, 'aNor'),
    aUV:  gl.getAttribLocation(progMain, 'aUV'),
    uProj: gl.getUniformLocation(progMain, 'uProj'),
    uView: gl.getUniformLocation(progMain, 'uView'),
    uModel: gl.getUniformLocation(progMain, 'uModel'),
    uEye: gl.getUniformLocation(progMain, 'uEye'),
    uLightDir: gl.getUniformLocation(progMain, 'uLightDir'),
    uBaseColor: gl.getUniformLocation(progMain, 'uBaseColor'),
    uMetal: gl.getUniformLocation(progMain, 'uMetal'),
    uRough: gl.getUniformLocation(progMain, 'uRough'),
  };
  const vs2 = compile(gl, VS2, gl.VERTEX_SHADER);
  const fs2 = compile(gl, FS2, gl.FRAGMENT_SHADER);
  progLine = link(gl, vs2, fs2);
  loc2 = {
    aPos: gl.getAttribLocation(progLine, 'aPos'),
    uProj: gl.getUniformLocation(progLine, 'uProj'),
    uView: gl.getUniformLocation(progLine, 'uView'),
    uModel: gl.getUniformLocation(progLine, 'uModel'),
    uColor: gl.getUniformLocation(progLine, 'uColor'),
  };
}

/* --------------------------- Cloth simulation --------------------------- */
const CLOTH_W = 1.2, CLOTH_H = 1.2;
const NX = 32, NY = 32;
const NPTS = NX*NY;
const DX = CLOTH_W/(NX-1), DY = CLOTH_H/(NY-1);
const GRAV = [0,-9.8,0];
const DAMP = 0.0015;
const SUBSTEPS = 2;
const ITER = 10;
const PICK_RADIUS = 0.06;

const pos = new Float32Array(NPTS*3);
const prev= new Float32Array(NPTS*3);
const nor = new Float32Array(NPTS*3);
const invm= new Float32Array(NPTS);
const uv  = new Float32Array(NPTS*2);
let idx;

const cons = [];
function pIndex(ix,iy){ return iy*NX + ix; }
function posOf(i){ return [pos[3*i],pos[3*i+1],pos[3*i+2]]; }
function setPos(i, v){ pos[3*i]=v[0]; pos[3*i+1]=v[1]; pos[3*i+2]=v[2]; }

function initClothAt(origin=[0,1.2,0], right=[1,0,0], up=[0,0,-1]){
  cons.length = 0;
  for(let y=0;y<NY;y++){
    for(let x=0;x<NX;x++){
      const i = pIndex(x,y);
      const u0 = x/(NX-1), v0 = y/(NY-1);
      const base = V.add(origin, V.add(V.mul(right, (u0-0.5)*CLOTH_W), V.mul(up, (v0-0.5)*CLOTH_H)));
      const jitter = ((x+y)&1)?0.0005:-0.0005;
      pos[3*i]=base[0]; pos[3*i+1]=base[1]+0.3 + jitter; pos[3*i+2]=base[2];
      prev[3*i]=pos[3*i]; prev[3*i+1]=pos[3*i+1]; prev[3*i+2]=pos[3*i+2];
      invm[i]  = 1.0;
      uv[2*i]=u0; uv[2*i+1]=v0;
    }
  }
  function addC(i,j,s){ cons.push(i,j,s,1.0); }
  for(let y=0;y<NY;y++){
    for(let x=0;x<NX;x++){
      const i = pIndex(x,y);
      if(x+1<NX) addC(i, pIndex(x+1,y), DX);
      if(y+1<NY) addC(i, pIndex(x, y+1), DY);
      if(x+1<NX && y+1<NY) addC(i, pIndex(x+1,y+1), Math.hypot(DX,DY));
      if(x>0 && y+1<NY) addC(i, pIndex(x-1,y+1), Math.hypot(DX,DY));
      if(x+2<NX) addC(i, pIndex(x+2,y), 2*DX);
      if(y+2<NY) addC(i, pIndex(x,y+2), 2*DY);
    }
  }
  const tris = [];
  for(let y=0;y<NY-1;y++){
    for(let x=0;x<NX-1;x++){
      const i0=pIndex(x,y), i1=pIndex(x+1,y), i2=pIndex(x,y+1), i3=pIndex(x+1,y+1);
      tris.push(i0,i2,i1,  i1,i2,i3);
    }
  }
  idx = (NPTS<65536) ? new Uint16Array(tris) : new Uint32Array(tris);
  recomputeNormals();
}
function recomputeNormals(){
  for(let i=0;i<3*NPTS;i++) nor[i]=0;
  for(let t=0;t<idx.length; t+=3){
    const i0=idx[t], i1=idx[t+1], i2=idx[t+2];
    const a=posOf(i0), b=posOf(i1), c=posOf(i2);
    const e1=V.sub(b,a), e2=V.sub(c,a);
    const n=V.cross(e1,e2);
    nor[3*i0]+=n[0]; nor[3*i0+1]+=n[1]; nor[3*i0+2]+=n[2];
    nor[3*i1]+=n[0]; nor[3*i1+1]+=n[1]; nor[3*i1+2]+=n[2];
    nor[3*i2]+=n[0]; nor[3*i2+1]+=n[1]; nor[3*i2+2]+=n[2];
  }
  for(let i=0;i<NPTS;i++){
    const n=[nor[3*i],nor[3*i+1],nor[3*i+2]];
    const nn=V.norm(n);
    nor[3*i]=nn[0]; nor[3*i+1]=nn[1]; nor[3*i+2]=nn[2];
  }
}
function integrate(dt){
  const damping = Math.exp(-DAMP*dt);
  for(let i=0;i<NPTS;i++){
    const ix=3*i;
    const x=[pos[ix],pos[ix+1],pos[ix+2]];
    const prevx=[prev[ix],prev[ix+1],prev[ix+2]];
    const vel = V.mul(V.sub(x,prevx), damping);
    const acc = V.mul(GRAV, dt*dt);
    const nx = V.add(V.add(x, vel), acc);
    prev[ix]=x[0]; prev[ix+1]=x[1]; prev[ix+2]=x[2];
    pos[ix]=nx[0]; pos[ix+1]=nx[1]; pos[ix+2]=nx[2];
  }
}
function satisfyConstraints(){
  for(let it=0; it<ITER; it++){
    for(let k=0;k<cons.length;k+=4){
      const i=cons[k], j=cons[k+1], rest=cons[k+2], stiff=cons[k+3];
      const ix=3*i, jx=3*j;
      const pi=[pos[ix],pos[ix+1],pos[ix+2]];
      const pj=[pos[jx],pos[jx+1],pos[jx+2]];
      let d=V.sub(pi,pj);
      const L=V.len(d)||1e-6;
      const invMassSum = invm[i]+invm[j] || 1e-6;
      const corr = V.mul(d, (1.0 - rest/L) * stiff);
      if(invm[i]>0){ pos[ix]-=corr[0]*(invm[i]/invMassSum); pos[ix+1]-=corr[1]*(invm[i]/invMassSum); pos[ix+2]-=corr[2]*(invm[i]/invMassSum); }
      if(invm[j]>0){ pos[jx]+=corr[0]*(invm[j]/invMassSum); pos[jx+1]+=corr[1]*(invm[j]/invMassSum); pos[jx+2]+=corr[2]*(invm[j]/invMassSum); }
    }
    collideWithPlane();
    handCollision();
    applyGrabs();
  }
}

/* ------------------------ Plane & hit-test reticle ----------------------- */
let planeSet = false;
let planePoint = [0, 0.75, 0];
let planeNormal = [0, 1, 0];
let reticleActive = false;
let reticleModel = new Float32Array(mat4Identity());

function collideWithPlane(){
  const N = planeNormal;
  const P0 = planePoint;
  for(let i=0;i<NPTS;i++){
    if(invm[i]===0) continue;
    const ix=3*i;
    const p=[pos[ix],pos[ix+1],pos[ix+2]];
    const d = V.dot(V.sub(p,P0), N);
    if(d<0){
      const corr = V.mul(N, -d);
      pos[ix]+=corr[0]; pos[ix+1]+=corr[1]; pos[ix+2]+=corr[2];
      prev[ix]+=corr[0]*0.6; prev[ix+1]+=corr[1]*0.6; prev[ix+2]+=corr[2]*0.6;
    }
  }
}

/* ------------------------------ Hand input ------------------------------ */
const hands = { left: null, right: null };
const handState = {
  left:  { pinch:false, wasPinch:false, pinchPos:[0,0,0], grabId:-1, consumed:false },
  right: { pinch:false, wasPinch:false, pinchPos:[0,0,0], grabId:-1, consumed:false }
};
const PALM_RAD = 0.07;

function handCollision(){
  for(const side of ['left','right']){
    const h = hands[side]; if(!h) continue;
    const palmp = h.palm; if(!palmp) continue;
    const c = [palmp.x, palmp.y, palmp.z];
    const r = PALM_RAD;
    for(let i=0;i<NPTS;i++){
      const ix = 3*i;
      const p = [pos[ix],pos[ix+1],pos[ix+2]];
      const d = V.sub(p,c);
      const L = V.len(d);
      if(L < r){
        const n = L>1e-6 ? V.mul(d, 1/L) : [0,1,0];
        const corr = V.mul(n, r-L);
        pos[ix]+=corr[0]; pos[ix+1]+=corr[1]; pos[ix+2]+=corr[2];
      }
    }
  }
}
function applyGrabs(){
  for(const side of ['left','right']){
    const st = handState[side];
    if(st.grabId>=0){
      const g = st.grabId;
      const ix = 3*g;
      pos[ix] = st.pinchPos[0];
      pos[ix+1] = st.pinchPos[1];
      pos[ix+2] = st.pinchPos[2];
      prev[ix]=pos[ix]; prev[ix+1]=pos[ix+1]; prev[ix+2]=pos[ix+2];
    }
  }
}
function nearestParticle(to, maxR = PICK_RADIUS){
  let best=-1, bestD=maxR;
  for(let i=0;i<NPTS;i++){
    const ix=3*i;
    const p=[pos[ix],pos[ix+1],pos[ix+2]];
    const d = V.len(V.sub(p,to));
    if(d<bestD){ bestD=d; best=i; }
  }
  return best;
}
function updateHands(frame){
  for(const input of session.inputSources){
    if(!input.hand) continue;
    const handedness = input.handedness;
    const hand = input.hand;
    function jp(name){
      const space = hand.get(name);
      if(!space) return null;
      const pose = frame.getJointPose(space, refSpace);
      return pose ? pose.transform.position : null;
    }
    const thumb = jp('thumb-tip');
    const index = jp('index-finger-tip');
    const palmP = jp('wrist') || jp('index-finger-metacarpal');
    hands[handedness] = { thumb, index, palm: palmP };

    const st = handState[handedness];
    st.wasPinch = st.pinch;
    if(thumb && index){
      const d = Math.hypot(thumb.x-index.x, thumb.y-index.y, thumb.z-index.z);
      st.pinch = d < 0.03;
      if(st.pinch){
        st.pinchPos = [(thumb.x+index.x)/2, (thumb.y+index.y)/2, (thumb.z+index.z)/2];
      }
    } else {
      st.pinch = false;
    }
    st.consumed = false;

    // ----- Pinch begin routing: UI panel -> Reticle placement -> Gizmo -> Cloth -----
    if(st.pinch && !st.wasPinch){
      if(tryUIPress(st.pinchPos)){ st.consumed=true; continue; }

      if(!planeSet && reticleActive){
        placePlaneAndSpawnFromReticle();
        st.consumed=true; continue;
      }

      if(gizmo.visible && tryGizmoGrabBegin(st)){ st.consumed=true; continue; }

      // cloth pinch-grab (only if not consumed and gizmo not active)
      const id = nearestParticle(st.pinchPos, PICK_RADIUS);
      if(id>=0 && !gizmo.activeHandle){
        st.grabId = id;
        invm[id] = 0.0;
      }
    }

    // ----- Pinch move (gizmo drag) -----
    if(st.pinch && st.wasPinch && gizmo.activeHandle && gizmo.activeHand===handedness){
      handleGizmoDrag(st);
      st.consumed = true;
    }

    // ----- Pinch end -----
    if(!st.pinch && st.wasPinch){
      if(gizmo.activeHandle && gizmo.activeHand===handedness){
        gizmo.activeHandle = null;
        gizmo.activeHand = null;
      }
      if(st.grabId>=0){
        invm[st.grabId] = 1.0;
        st.grabId = -1;
      }
    }
  }
}

/* ------------------------------- Reticle -------------------------------- */
function buildReticleGeometry(){
  const ring = [];
  const R = 0.08, N = 48;
  for(let i=0;i<N;i++){
    const t = (i/N)*Math.PI*2;
    ring.push(Math.cos(t)*R, 0, Math.sin(t)*R);
  }
  bufReticle = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, bufReticle);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ring), gl.STATIC_DRAW);

  // shared dynamic buffer for triangles/lines
  bufTemp = gl.createBuffer();
}

/* --------------------------- Cloth GL buffers --------------------------- */
function initClothBuffers(){
  bufPos = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW);
  bufNor = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufNor); gl.bufferData(gl.ARRAY_BUFFER, nor, gl.DYNAMIC_DRAW);
  bufUV  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, bufUV); gl.bufferData(gl.ARRAY_BUFFER, uv,  gl.STATIC_DRAW);
  bufIdx = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
}
function updateClothBuffers(){
  gl.bindBuffer(gl.ARRAY_BUFFER, bufPos); gl.bufferSubData(gl.ARRAY_BUFFER, 0, pos);
  gl.bindBuffer(gl.ARRAY_BUFFER, bufNor); gl.bufferSubData(gl.ARRAY_BUFFER, 0, nor);
}

/* ------------------------------ Rendering ------------------------------- */
function drawCloth(view, viewMat, projMat){
  gl.useProgram(progMain);
  gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
  gl.enableVertexAttribArray(loc.aPos);
  gl.vertexAttribPointer(loc.aPos, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, bufNor);
  gl.enableVertexAttribArray(loc.aNor);
  gl.vertexAttribPointer(loc.aNor, 3, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, bufUV);
  gl.enableVertexAttribArray(loc.aUV);
  gl.vertexAttribPointer(loc.aUV, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx);

  gl.uniformMatrix4fv(loc.uProj, false, projMat);
  gl.uniformMatrix4fv(loc.uView, false, viewMat);
  gl.uniformMatrix4fv(loc.uModel, false, mat4Identity());
  const eye = view.transform.position;
  gl.uniform3f(loc.uEye, eye.x, eye.y, eye.z);
  gl.uniform3f(loc.uLightDir, 0.4, 0.9, 0.3);
  gl.uniform3f(loc.uBaseColor, 0.85, 0.25, 0.25);
  gl.uniform1f(loc.uMetal, 0.0);
  gl.uniform1f(loc.uRough, 0.35);

  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);
  gl.drawElements(gl.TRIANGLES, idx.length, gl.UNSIGNED_SHORT, 0);
}
function drawReticle(viewMat, projMat, color=[0.2,1,0.6,1]){
  if(!reticleActive) return;
  gl.useProgram(progLine);
  gl.bindBuffer(gl.ARRAY_BUFFER, bufReticle);
  gl.enableVertexAttribArray(loc2.aPos);
  gl.vertexAttribPointer(loc2.aPos, 3, gl.FLOAT, false, 0, 0);
  gl.uniformMatrix4fv(loc2.uProj, false, projMat);
  gl.uniformMatrix4fv(loc2.uView, false, viewMat);
  gl.uniformMatrix4fv(loc2.uModel, false, reticleModel);
  gl.uniform4f(loc2.uColor, color[0],color[1],color[2],color[3]);
  gl.disable(gl.DEPTH_TEST);
  gl.drawArrays(gl.LINE_LOOP, 0, 48);
}

/* --------------------------- In‑scene UI panel --------------------------- */
const ui = {
  enabled: true,
  model: new Float32Array(mat4Identity()),
  invModel: new Float32Array(mat4Identity()),
  // Button layout (local panel space, z=0 plane)
  buttons: [
    { name:'Reset', color:[0.96,0.4,0.4,1], center:[-0.14,0.00,0], half:[0.11,0.06], action:()=>resetAll() },
    { name:'Rearm', color:[0.40,0.96,0.40,1], center:[0.00,0.00,0],  half:[0.11,0.06], action:()=>rearmReticle() },
    { name:'Gizmo', color:[1.00,0.86,0.30,1], center:[+0.14,0.00,0], half:[0.11,0.06], action:()=>toggleGizmo() },
  ],
  hoverIndex: -1,
};
function updateUIPanel(view){ // follow-head, ~0.55m forward, slight down
  const m = new Float32Array(view.transform.matrix);
  const headPos = [m[12],m[13],m[14]];
  const right = V.norm([m[0],m[1],m[2]]);
  const up    = V.norm([m[4],m[5],m[6]]);
  const fwd   = V.norm([-m[8],-m[9],-m[10]]); // camera -Z
  const pos = V.add(headPos, V.add(V.mul(fwd, 0.55), V.mul(up, -0.05)));
  ui.model = composeFromBasis(right, up, fwd, pos);
  ui.invModel = mat4InverseRigid(ui.model);
}
function drawUIPanel(viewMat, projMat){
  if(!ui.enabled) return;
  gl.useProgram(progLine);
  gl.uniformMatrix4fv(loc2.uProj, false, projMat);
  gl.uniformMatrix4fv(loc2.uView, false, viewMat);

  // draw panel backplate (rounded-ish by just a bigger dim)
  function drawRect(center, half, col, z=0){
    const [cx,cy]=center, [hx,hy]=half;
    const verts = new Float32Array([
      cx-hx, cy-hy, z,  cx+hx, cy-hy, z,  cx+hx, cy+hy, z,
      cx-hx, cy-hy, z,  cx+hx, cy+hy, z,  cx-hx, cy+hy, z
    ]);
    gl.bindBuffer(gl.ARRAY_BUFFER, bufTemp);
    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(loc2.aPos);
    gl.vertexAttribPointer(loc2.aPos, 3, gl.FLOAT, false, 0, 0);
    gl.uniformMatrix4fv(loc2.uModel, false, ui.model);
    gl.uniform4f(loc2.uColor, col[0],col[1],col[2],col[3]);
    gl.enable(gl.DEPTH_TEST);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  // subtle backplate
  drawRect([0,0,0], [0.39,0.09], [0.08,0.10,0.14,0.65], 0.0);

  // buttons
  for(let i=0;i<ui.buttons.length;i++){
    const b=ui.buttons[i];
    const col = (i===ui.hoverIndex) ? [b.color[0],b.color[1],b.color[2],1] : b.color;
    drawRect(b.center,b.half,col,0.001);

    // simple icon per button (lines)
    const lines = [];
    if(b.name==='Reset'){ // circular arrow-ish
      const R=0.028, N=24;
      for(let k=0;k<N;k++){
        const t0=(k/N)*1.6*Math.PI-0.8, t1=((k+1)/N)*1.6*Math.PI-0.8;
        lines.push(b.center[0]+R*Math.cos(t0), b.center[1]+R*Math.sin(t0), 0.002);
        lines.push(b.center[0]+R*Math.cos(t1), b.center[1]+R*Math.sin(t1), 0.002);
      }
      // arrow head
      lines.push(b.center[0]+R*0.95, b.center[1]-0.005, 0.002, b.center[0]+R*1.08, b.center[1]+0.012, 0.002);
      lines.push(b.center[0]+R*0.95, b.center[1]-0.005, 0.002, b.center[0]+R*1.10, b.center[1]-0.020, 0.002);
    } else if(b.name==='Rearm'){ // crosshair
      const cx=b.center[0], cy=b.center[1];
      lines.push(cx-0.05,cy,0.002, cx+0.05,cy,0.002);
      lines.push(cx,cy-0.05,0.002, cx,cy+0.05,0.002);
      const N=24, R=0.035;
      for(let k=0;k<N;k++){
        const t0=(k/N)*2*Math.PI, t1=((k+1)/N)*2*Math.PI;
        lines.push(cx+R*Math.cos(t0), cy+R*Math.sin(t0), 0.002);
        lines.push(cx+R*Math.cos(t1), cy+R*Math.sin(t1), 0.002);
      }
    } else { // Gizmo icon (axes)
      const cx=b.center[0], cy=b.center[1];
      lines.push(cx,cy,0.002, cx+0.06,cy,0.002);
      lines.push(cx,cy,0.002, cx,cy+0.06,0.002);
      lines.push(cx,cy,0.002, cx-0.04,cy-0.04,0.002);
    }
    if(lines.length){
      gl.bindBuffer(gl.ARRAY_BUFFER, bufTemp);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.DYNAMIC_DRAW);
      gl.vertexAttribPointer(loc2.aPos, 3, gl.FLOAT, false, 0, 0);
      gl.uniformMatrix4fv(loc2.uModel, false, ui.model);
      gl.uniform4f(loc2.uColor, 0.95,0.95,0.98,1);
      gl.drawArrays(gl.LINES, 0, lines.length/3);
    }
  }
}
// test for press
function tryUIPress(worldPinch){
  if(!ui.enabled) return false;
  const lp = transformPoint(ui.invModel, worldPinch); // panel local
  if(Math.abs(lp[2])>0.06) return false; // too far from plane
  for(let i=0;i<ui.buttons.length;i++){
    const b=ui.buttons[i];
    if(Math.abs(lp[0]-b.center[0])<=b.half[0] && Math.abs(lp[1]-b.center[1])<=b.half[1]){
      b.action();
      return true;
    }
  }
  return false;
}
// hover effect (use nearest hand, if any)
function updateUIHover(){
  ui.hoverIndex = -1;
  for(const side of ['left','right']){
    const st = handState[side];
    if(!st.pinch) continue; // only while pinching (keeps it lightweight)
    const lp = transformPoint(ui.invModel, st.pinchPos);
    if(Math.abs(lp[2])>0.06) continue;
    for(let i=0;i<ui.buttons.length;i++){
      const b=ui.buttons[i];
      if(Math.abs(lp[0]-b.center[0])<=b.half[0] && Math.abs(lp[1]-b.center[1])<=b.half[1]){
        ui.hoverIndex = i; return;
      }
    }
  }
}

/* ---------------------------- Transform gizmo ---------------------------- */
const gizmo = {
  visible:false,
  origin:[0,1,0],
  axisU:[1,0,0], axisV:[0,0,1], axisN:[0,1,0], // tangent axes, normal
  len:0.22, ringR:0.16,
  activeHandle:null, // 'TX','TY','TZ','RY'
  activeHand:null,
  ref:{} // per-drag refs (s0, angle0, etc.)
};
function computeClothCenter(){
  let cx=0,cy=0,cz=0;
  for(let i=0;i<NPTS;i++){ cx+=pos[3*i]; cy+=pos[3*i+1]; cz+=pos[3*i+2]; }
  return [cx/NPTS, cy/NPTS, cz/NPTS];
}
function refreshGizmoBasis(){
  gizmo.origin = computeClothCenter();
  gizmo.axisN = V.norm(planeNormal);
  const worldUp = [0,1,0];
  let u = V.cross(gizmo.axisN, worldUp);
  if(V.len(u)<1e-3) u = [1,0,0]; // fallback if parallel
  gizmo.axisU = V.norm(u);
  gizmo.axisV = V.norm(V.cross(gizmo.axisN, gizmo.axisU));
}
function toggleGizmo(){
  gizmo.visible = !gizmo.visible;
  if(gizmo.visible){
    // release any cloth grabs
    for(const s of ['left','right']){
      const st=handState[s];
      if(st.grabId>=0){ invm[st.grabId]=1.0; st.grabId=-1; }
    }
    refreshGizmoBasis();
    setMsg('Gizmo ON: grab X/Z/Y to move, ring to rotate.');
  } else {
    gizmo.activeHandle=null; gizmo.activeHand=null;
    setMsg('Gizmo OFF.');
  }
}
function drawGizmo(viewMat, projMat){
  if(!gizmo.visible) return;
  gl.useProgram(progLine);
  gl.uniformMatrix4fv(loc2.uProj, false, projMat);
  gl.uniformMatrix4fv(loc2.uView, false, viewMat);

  function drawLines(points, col){
    gl.bindBuffer(gl.ARRAY_BUFFER, bufTemp);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(loc2.aPos);
    gl.vertexAttribPointer(loc2.aPos, 3, gl.FLOAT, false, 0, 0);
    const M = composeFromBasis([1,0,0],[0,1,0],[0,0,1], [0,0,0]);
    gl.uniformMatrix4fv(loc2.uModel, false, M);
    gl.uniform4f(loc2.uColor, col[0],col[1],col[2],col[3]);
    gl.enable(gl.DEPTH_TEST);
    gl.drawArrays(gl.LINES, 0, points.length/3);
  }
  const o = gizmo.origin, L=gizmo.len, U=gizmo.axisU, Vt=gizmo.axisV, N=gizmo.axisN;
  const xEnd = V.add(o, V.mul(U,L));
  const zEnd = V.add(o, V.mul(Vt,L));
  const yEnd = V.add(o, V.mul(N,L*0.8));
  // axes
  drawLines([ o[0],o[1],o[2], xEnd[0],xEnd[1],xEnd[2] ], gizmo.activeHandle==='TX'?[1,0.5,0.5,1]:[1,0.2,0.2,1]); // X (red-ish)
  drawLines([ o[0],o[1],o[2], zEnd[0],zEnd[1],zEnd[2] ], gizmo.activeHandle==='TZ'?[0.5,0.5,1,1]:[0.2,0.2,1,1]); // Z (blue-ish)
  drawLines([ o[0],o[1],o[2], yEnd[0],yEnd[1],yEnd[2] ], gizmo.activeHandle==='TY'?[0.5,1,0.5,1]:[0.2,1,0.2,1]); // Y (green-ish)
  // ring around N in U/V plane
  const R=gizmo.ringR, steps=48; const ringPts=[];
  for(let i=0;i<steps;i++){
    const t0=(i/steps)*2*Math.PI, t1=((i+1)/steps)*2*Math.PI;
    const p0 = V.add( o, V.add( V.mul(U,R*Math.cos(t0)), V.mul(Vt,R*Math.sin(t0)) ) );
    const p1 = V.add( o, V.add( V.mul(U,R*Math.cos(t1)), V.mul(Vt,R*Math.sin(t1)) ) );
    ringPts.push(p0[0],p0[1],p0[2], p1[0],p1[1],p1[2]);
  }
  const ringCol = gizmo.activeHandle==='RY'?[1,1,0.5,1]:[1,1,0.2,1];
  drawLines(ringPts, ringCol);
}
function distPointToSegment(p, a, b){
  const ab = V.sub(b,a), ap = V.sub(p,a);
  const t = Math.max(0, Math.min(1, V.dot(ap,ab)/(V.dot(ab,ab)||1e-6)));
  const q = V.add(a, V.mul(ab,t));
  return { d: V.len(V.sub(p,q)), t, q };
}
function tryGizmoGrabBegin(st){
  const p = st.pinchPos, o=gizmo.origin, U=gizmo.axisU, Vt=gizmo.axisV, N=gizmo.axisN;
  const L=gizmo.len, R=gizmo.ringR;
  // test axes first
  const xEnd = V.add(o, V.mul(U,L));
  const zEnd = V.add(o, V.mul(Vt,L));
  const yEnd = V.add(o, V.mul(N,L*0.8));
  const thr = 0.03;
  const dx = distPointToSegment(p, o, xEnd);
  if(dx.d<thr){ gizmo.activeHandle='TX'; gizmo.activeHand=st===handState.left?'left':'right'; gizmo.ref.s = V.dot(V.sub(p,o),U); return true; }
  const dz = distPointToSegment(p, o, zEnd);
  if(dz.d<thr){ gizmo.activeHandle='TZ'; gizmo.activeHand=st===handState.left?'left':'right'; gizmo.ref.s = V.dot(V.sub(p,o),Vt); return true; }
  const dy = distPointToSegment(p, o, yEnd);
  if(dy.d<thr){ gizmo.activeHandle='TY'; gizmo.activeHand=st===handState.left?'left':'right'; gizmo.ref.s = V.dot(V.sub(p,o),N); return true; }
  // test ring (project to plane)
  const w = V.sub(p,o);
  const radial = Math.hypot( V.dot(w,U), V.dot(w,Vt) );
  const height = Math.abs(V.dot(w,N));
  if(Math.abs(radial - R) < 0.03 && height < 0.04){
    gizmo.activeHandle='RY'; gizmo.activeHand=st===handState.left?'left':'right';
    gizmo.ref.angle = Math.atan2( V.dot(w,Vt), V.dot(w,U) );
    return true;
  }
  return false;
}
function handleGizmoDrag(st){
  const p = st.pinchPos, o=gizmo.origin, U=gizmo.axisU, Vt=gizmo.axisV, N=gizmo.axisN;
  if(gizmo.activeHandle==='TX'){
    const s = V.dot(V.sub(p,o),U); const ds = s - gizmo.ref.s; gizmo.ref.s = s;
    translateCloth(V.mul(U, ds)); gizmo.origin = V.add(gizmo.origin, V.mul(U,ds));
  } else if(gizmo.activeHandle==='TZ'){
    const s = V.dot(V.sub(p,o),Vt); const ds = s - gizmo.ref.s; gizmo.ref.s = s;
    translateCloth(V.mul(Vt, ds)); gizmo.origin = V.add(gizmo.origin, V.mul(Vt,ds));
  } else if(gizmo.activeHandle==='TY'){
    const s = V.dot(V.sub(p,o),N); const ds = s - gizmo.ref.s; gizmo.ref.s = s;
    translateCloth(V.mul(N, ds)); gizmo.origin = V.add(gizmo.origin, V.mul(N,ds));
  } else if(gizmo.activeHandle==='RY'){
    const w = V.sub(p,o);
    const ang = Math.atan2( V.dot(w,Vt), V.dot(w,U) );
    let da = ang - gizmo.ref.angle;
    // unwrap small discontinuities
    if(da> Math.PI) da -= 2*Math.PI;
    if(da<-Math.PI) da += 2*Math.PI;
    rotateClothAround(o, N, da);
    gizmo.ref.angle = ang;
  }
}
function translateCloth(delta){
  for(let i=0;i<NPTS;i++){
    const ix=3*i;
    pos[ix]+=delta[0]; pos[ix+1]+=delta[1]; pos[ix+2]+=delta[2];
    prev[ix]+=delta[0]; prev[ix+1]+=delta[1]; prev[ix+2]+=delta[2];
  }
}
function rotateClothAround(origin, axis, angle){
  for(let i=0;i<NPTS;i++){
    const ix=3*i;
    const p = [pos[ix]-origin[0], pos[ix+1]-origin[1], pos[ix+2]-origin[2]];
    const pr = rodrigues(p, axis, angle);
    pos[ix]=origin[0]+pr[0]; pos[ix+1]=origin[1]+pr[1]; pos[ix+2]=origin[2]+pr[2];
    const q = [prev[ix]-origin[0], prev[ix+1]-origin[1], prev[ix+2]-origin[2]];
    const qr = rodrigues(q, axis, angle);
    prev[ix]=origin[0]+qr[0]; prev[ix+1]=origin[1]+qr[1]; prev[ix+2]=origin[2]+qr[2];
  }
}

/* ------------------------------ AR session ------------------------------ */
const msg = document.getElementById('msg');
const statusDot = document.getElementById('statusDot');
function setMsg(s){ msg.textContent = s; }
function setDot(ok){ statusDot.style.background = ok ? '#8fd' : '#f66'; }

async function enterAR(){
  if(!navigator.xr) { setMsg('WebXR not available.'); setDot(false); return; }
  createGL();
  initPrograms();
  buildReticleGeometry();
  setMsg('Requesting AR session…');

  session = await navigator.xr.requestSession('immersive-ar', {
    requiredFeatures: ['local-floor','hit-test'],
    optionalFeatures: ['hand-tracking','dom-overlay','anchors','bounded-floor'],
    domOverlay: { root: document.body }
  });

  await gl.makeXRCompatible();
  baseLayer = new XRWebGLLayer(session, gl, { alpha:true, antialias:true });
  session.updateRenderState({ baseLayer });

  refSpace = await session.requestReferenceSpace('local-floor');
  viewerSpace = await session.requestReferenceSpace('viewer');
  hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

  session.addEventListener('end', ()=>{ setMsg('Session ended.'); setDot(false); });
  session.addEventListener('inputsourceschange', ()=>{ /* keep default */ });

  initClothAt([0,1.2, -0.5]);
  initClothBuffers();

  setMsg('Look at your table until the reticle locks; pinch to place.');
  setDot(true);

  session.requestAnimationFrame(onXRFrame);
}
function placePlaneAndSpawnFromReticle(){
  const q = quatFromMat(reticleModel);
  const n = V.norm(quatToBasisY(q));
  planePoint = [reticleModel[12], reticleModel[13], reticleModel[14]];
  planeNormal = (n[1] < 0 ? V.mul(n,-1) : n);
  planeSet = true;
  const right = [1,0,0], up = [0,0,-1];
  const spawn = V.add(planePoint, V.mul(planeNormal, 0.35));
  initClothAt(spawn, right, up);
  initClothBuffers();
  refreshGizmoBasis();
  setMsg('Plane placed. Use the 3D panel or gizmo; pinch near the cloth to grab.');
}
function resetAll(){
  planeSet = false;
  reticleActive = false;
  initClothAt([0,1.2,-0.5]);
  initClothBuffers();
  gizmo.visible=false; gizmo.activeHandle=null; gizmo.activeHand=null;
  setMsg('Reset. Look at the table and pinch to place the plane.');
  for(const s of ['left','right']){
    const st=handState[s];
    if(st.grabId>=0){ invm[st.grabId]=1.0; st.grabId=-1; }
  }
}
function rearmReticle(){
  planeSet=false;
  reticleActive=false; // will turn on as soon as a hit test returns
  setMsg('Reticle re-armed. Look at your table and pinch to place plane.');
}

/* ------------------------------- UI wiring ------------------------------ */
document.getElementById('enter').addEventListener('click', ()=>{
  enterAR().catch(err=>{
    console.error(err);
    setMsg('Failed to start AR: ' + err.message);
    setDot(false);
  });
});
document.getElementById('reset').addEventListener('click', resetAll);

/* ------------------------------ Main frame ------------------------------ */
let lastTime = 0;
function onXRFrame(t, frame){
  const dt = lastTime ? Math.min((t - lastTime)/1000, 1/30) : 1/90;
  lastTime = t;

  const pose = frame.getViewerPose(refSpace);
  if(!pose){ session.requestAnimationFrame(onXRFrame); return; }

  // Hit test for reticle (until plane is set)
  if(!planeSet && hitTestSource){
    const hits = frame.getHitTestResults(hitTestSource);
    if(hits.length){
      const hit = hits[0];
      const hitPose = hit.getPose(refSpace);
      reticleActive = true;
      reticleModel = mat4FromPose(hitPose.transform);
    } else {
      reticleActive = false;
    }
  }

  // Update UI panel anchor (use first view)
  updateUIPanel(pose.views[0]);

  // Hand tracking & interactions
  updateHands(frame);

  // Step simulation
  const step = (dt / SUBSTEPS);
  for(let s=0;s<SUBSTEPS;s++){
    integrate(step);
    satisfyConstraints();
  }
  recomputeNormals();
  updateClothBuffers();

  // Hover effect (optional)
  updateUIHover();

  // Render
  gl.bindFramebuffer(gl.FRAMEBUFFER, baseLayer.framebuffer);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  for(const view of pose.views){
    const vp = baseLayer.getViewport(view);
    gl.viewport(vp.x, vp.y, vp.width, vp.height);

    const proj = view.projectionMatrix;
    const viewMat = mat4InverseRigid(view.transform.matrix);

    // Reticle
    drawReticle(viewMat, proj);

    // Cloth
    drawCloth(view, viewMat, proj);

    // Gizmo (on top of scene)
    drawGizmo(viewMat, proj);

    // In-scene UI
    drawUIPanel(viewMat, proj);
  }

  session.requestAnimationFrame(onXRFrame);
}

setMsg('Ready. Tap "Enter Mixed Reality" on Quest 3.');
setDot(false);
</script>
</body>
</html>
